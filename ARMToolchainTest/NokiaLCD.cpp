#include "GalagoAPI.h"

using namespace Galago;

static byte const kBigDigitFragments[]  =	//50 bytes
{
	0x00, 0x00, 0x00, 0x00, 0x00,	//0: empty
	0xFC, 0xFE, 0xFF, 0xFF, 0x1F,	//1: top left of 05689. reversed is top right of 023789
	0x1C, 0x1E, 0x1F, 0x1F, 0x0F,	//2: top left of 237. reversed is top right of 56
	0xFC, 0xFE, 0xFF, 0xFF, 0x0F,	//3: top left of 4. reversed is top right of 14
	
	0xFF, 0xFF, 0xFF, 0xFF, 0x00,	//4: left of 0, reversed is right of 017
	0xF0, 0xF8, 0xFC, 0xFC, 0x7C,	//5: left of 2. reversed is right of 56
	0x1F, 0x3F, 0x3F, 0x3F, 0x3E,	//6: left of 459. reversed is right of 2
	0xFF, 0xFF, 0xFF, 0xFF, 0x7E,	//7: left of 68. reversed is right of 3489
	
	0x3F, 0x7F, 0xFF, 0xFF, 0xF8,	//8: bottom left of 0268. reversed is right of 035689
	0x38, 0x78, 0xF8, 0xF8, 0xF0,	//9: bottom left of 359. reversed is right of 2
	0x3F, 0x7F, 0xFF, 0xFF, 0x00,	//A: reversed is bottom right of 147
};


static byte const kBigDigitTable[] =	//60 bytes
{
	0x21, 0x0F, 0x54, 0x00, 0x98, 0xF0,	//0
	0x40, 0x00, 0x50, 0x00, 0xB0, 0x00,	//1
	0x22, 0x0F, 0x75, 0x3C, 0xA8, 0xF0,	//2
	0x22, 0x0F, 0x80, 0x3C, 0x99, 0xF0,	//3
	0x43, 0x00, 0x86, 0x3C, 0xB0, 0x00,	//4
	0x31, 0x0F, 0x66, 0x3C, 0x99, 0xF0,	//5
	0x31, 0x0F, 0x67, 0x3C, 0x98, 0xF0,	//6
	0x22, 0x0F, 0x50, 0x00, 0xB0, 0x00,	//7
	0x21, 0x0F, 0x87, 0x3C, 0x98, 0xF0,	//8
	0x21, 0x0F, 0x86, 0x3C, 0x99, 0xF0,	//9
};

static byte const kSmallDigitPixels[] =	//50 bytes
{
	0xFE, 0x82, 0x82, 0xFE,	//0
	0x00, 0x00, 0x00, 0xFE,	//1
	0xF2, 0x92, 0x92, 0x9E,	//2
	0x92, 0x92, 0x92, 0xFE,	//3
	0x1E, 0x10, 0x10, 0xFE,	//4
	0x9E, 0x92, 0x92, 0xF2,	//5
	0xFE, 0x92, 0x92, 0xF2,	//6
	0x02, 0x02, 0x02, 0xFE,	//7
	0xFE, 0x92, 0x92, 0xFE,	//8
	0x9E, 0x92, 0x92, 0xFE,	//9
	0xC0, 0xC0,				//.
};

//general-purpose 5*7 font, upper and lower case ascii-32 mapping
static byte const kRegularFont[] =
{
	0x00, 0x00, 0x00, 0x00, 0x00,	//space
	0x00, 0x00, 0x2f, 0x00, 0x00,	//!
	0x00, 0x07, 0x00, 0x07, 0x00,	//"
	0x14, 0x7f, 0x14, 0x7f, 0x14,	//#
	0x24, 0x2a, 0x7f, 0x2a, 0x12,	//$
	0xc4, 0xc8, 0x10, 0x26, 0x46,	//%
	0x36, 0x49, 0x55, 0x22, 0x50,	//&
	0x00, 0x05, 0x03, 0x00, 0x00,	//'
	0x00, 0x1c, 0x22, 0x41, 0x00,	//(
	0x00, 0x41, 0x22, 0x1c, 0x00,	//)
	0x14, 0x08, 0x3E, 0x08, 0x14,	//*
	0x08, 0x08, 0x3E, 0x08, 0x08,	//+
	0x00, 0x00, 0x50, 0x30, 0x00,	//,
	0x10, 0x10, 0x10, 0x10, 0x10,	//-
	0x00, 0x60, 0x60, 0x00, 0x00,	//.
	0x20, 0x10, 0x08, 0x04, 0x02,	///
	0x3E, 0x51, 0x49, 0x45, 0x3E,	//0
	0x00, 0x42, 0x7F, 0x40, 0x00,	//1
	0x42, 0x61, 0x51, 0x49, 0x46,	//2
	0x21, 0x41, 0x45, 0x4B, 0x31,	//3
	0x18, 0x14, 0x12, 0x7F, 0x10,	//4
	0x27, 0x45, 0x45, 0x45, 0x39,	//5
	0x3C, 0x4A, 0x49, 0x49, 0x30,	//6
	0x01, 0x71, 0x09, 0x05, 0x03,	//7
	0x36, 0x49, 0x49, 0x49, 0x36,	//8
	0x06, 0x49, 0x49, 0x29, 0x1E,	//9
	0x00, 0x36, 0x36, 0x00, 0x00,	//:
	0x00, 0x56, 0x36, 0x00, 0x00,	//;
	0x08, 0x14, 0x22, 0x41, 0x00,	//<
	0x14, 0x14, 0x14, 0x14, 0x14,	//=
	0x00, 0x41, 0x22, 0x14, 0x08,	//>
	0x02, 0x01, 0x51, 0x09, 0x06,	//?
	0x32, 0x49, 0x59, 0x51, 0x3E,	//@
	0x7E, 0x11, 0x11, 0x11, 0x7E,	//A
	0x7F, 0x49, 0x49, 0x49, 0x36,	//B
	0x3E, 0x41, 0x41, 0x41, 0x22,	//C
	0x7F, 0x41, 0x41, 0x22, 0x1C,	//D
	0x7F, 0x49, 0x49, 0x49, 0x41,	//E
	0x7F, 0x09, 0x09, 0x09, 0x01,	//F
	0x3E, 0x41, 0x49, 0x49, 0x7A,	//G
	0x7F, 0x08, 0x08, 0x08, 0x7F,	//H
	0x00, 0x41, 0x7F, 0x41, 0x00,	//I
	0x20, 0x40, 0x41, 0x3F, 0x01,	//J
	0x7F, 0x08, 0x14, 0x22, 0x41,	//K
	0x7F, 0x40, 0x40, 0x40, 0x40,	//L
	0x7F, 0x02, 0x0C, 0x02, 0x7F,	//M
	0x7F, 0x04, 0x08, 0x10, 0x7F,	//N
	0x3E, 0x41, 0x41, 0x41, 0x3E,	//O
	0x7F, 0x09, 0x09, 0x09, 0x06,	//P
	0x3E, 0x41, 0x51, 0x21, 0x5E,	//Q
	0x7F, 0x09, 0x19, 0x29, 0x46,	//R
	0x46, 0x49, 0x49, 0x49, 0x31,	//S
	0x01, 0x01, 0x7F, 0x01, 0x01,	//T
	0x3F, 0x40, 0x40, 0x40, 0x3F,	//U
	0x1F, 0x20, 0x40, 0x20, 0x1F,	//V
	0x3F, 0x40, 0x38, 0x40, 0x3F,	//W
	0x63, 0x14, 0x08, 0x14, 0x63,	//X
	0x07, 0x08, 0x70, 0x08, 0x07,	//Y
	0x61, 0x51, 0x49, 0x45, 0x43,	//Z
	0x00, 0x7F, 0x41, 0x41, 0x00,	//[
	0x08, 0x1C, 0x3E, 0x08, 0x08,	//left-pointing arrow
	0x00, 0x41, 0x41, 0x7F, 0x00,	//]
	0x04, 0x02, 0x01, 0x02, 0x04,	//^
	0x40, 0x40, 0x40, 0x40, 0x40,	//_
	0x00, 0x01, 0x02, 0x04, 0x00,	//'
    0x20, 0x54, 0x54, 0x54, 0x78,	//a
    0x7F, 0x48, 0x44, 0x44, 0x38,	//b
    0x38, 0x44, 0x44, 0x44, 0x20,	//c
    0x38, 0x44, 0x44, 0x48, 0x7F,	//d
    0x38, 0x54, 0x54, 0x54, 0x18,	//e
    0x08, 0x7E, 0x09, 0x01, 0x02,	//f
    0x0C, 0x52, 0x52, 0x52, 0x3E,	//g
    0x7F, 0x08, 0x04, 0x04, 0x78,	//h
    0x00, 0x44, 0x7D, 0x40, 0x00,	//i
    0x20, 0x40, 0x44, 0x3D, 0x00,	//j
    0x7F, 0x10, 0x28, 0x44, 0x00,	//k
    0x00, 0x41, 0x7F, 0x40, 0x00,	//l
    0x7C, 0x04, 0x18, 0x04, 0x78,	//m
    0x7C, 0x08, 0x04, 0x04, 0x78,	//n
    0x38, 0x44, 0x44, 0x44, 0x38,	//o
    0x7C, 0x14, 0x14, 0x14, 0x08,	//p
    0x08, 0x14, 0x14, 0x18, 0x7C,	//q
    0x7C, 0x08, 0x04, 0x04, 0x08,	//r
    0x48, 0x54, 0x54, 0x54, 0x20,	//s
    0x04, 0x3F, 0x44, 0x40, 0x20,	//t
    0x3C, 0x40, 0x40, 0x20, 0x7C,	//u
    0x1C, 0x20, 0x40, 0x20, 0x1C,	//v
    0x3C, 0x40, 0x30, 0x40, 0x3C,	//w
    0x44, 0x28, 0x10, 0x28, 0x44,	//x
    0x0C, 0x50, 0x50, 0x50, 0x3C,	//y
    0x44, 0x64, 0x54, 0x4C, 0x44,	//z
};


static byte const kLCDInitSequence[] =
{
	0x21,   //switch to extended commands  
	0xE0,   //set value of Vop (controls contrast) = 0x80 | 0x60 (arbitrary)  
	0x04,   //set temperature coefficient  
	0x14,   //set bias mode to 1:48.  
	0x20,   //switch back to regular commands  
	0x0C,   //enable normal display (dark on light), horizontal addressing 
};

class NokiaLCD
{
public:
			NokiaLCD(IO::Pin resetPin, IO::Pin commandPin, IO::SPI spiPort = IO.spi):
				nReset(resetPin),
				nCommandMode(commandPin),
				spi(spiPort)
	{
		spi.setup();
	}
	
	void	init(void)
	{
		nReset.write(0);
		System.delay(200);
		nReset.write(1);
		System.delay(100);
		
		nCommandMode.write(0);
		spi.write(kLCDInitSequence, sizeof(kLCDInitSequence));
		nCommandMode.write(1);
		
		System.delay(50000);
	}

	void	clear(void)
	{
		for(int i = 0; i < (12 * 6); i++)	//12 column blocks of 7 pixels, 6 row blocks of 8 pixels makes 84 x 48
		{
			spi.write((byte const*)"\0\0\0\0\0\0\0", 7);	//send seven at a time for efficiency
		}
	}

	void	setCursor(int x, int yColumn)
	{
		nCommandMode.write(0);
		spi.write((byte)(0x80 | x));
		spi.write((byte)(0x40 | yColumn));
		nCommandMode.write(1);
	}

	void	renderBigDigit(byte digit, byte x, byte yColumn)
	{
		byte const* script = kBigDigitTable + digit * 6;
		
		setCursor(x, yColumn);

		for(byte row = 0; row < 3; row++)
		{
			byte control = *script++;
			
			byte const* pixels = kBigDigitFragments + (control & 0xF) * 5;
			spi.write(pixels, 5);
			
			byte fill = *script++;
			spi.write(fill, 10);
			
			pixels = kBigDigitFragments + (control >> 4) * 5;
			for(byte i = 0; i < 5; i++)
				spi.write(*(--pixels));
			
			setCursor(x, ++yColumn);
		}
	}

	void	renderSmallDigit(byte digit)
	{
		byte const* pixels = kSmallDigitPixels + (digit << 2);
		spi.write(*pixels, (digit < 10)? 4 : 2);
		spi.write('\0');
	}

	void	write(char const* text)
	{
		while(*text != '\0')
		{
			spi.write((byte*)kRegularFont + ((*text - 32) * 5), 5);
			spi.write('\0');
			text++;
		}
	}

private:
	IO::Pin		nReset;
	IO::Pin		nCommandMode;
	IO::SPI		spi;
};







int main(void)
{
	//NokiaLCD lcd(IO.P6, IO.P7);

	//lcd.init();
	//lcd.clear();

	//lcd.setCursor(0, 0);
	//lcd.write("Nokia 3310 LCD");

	IO.P5.setMode(IO::Pin::DigitalOutput);

	int i = 0;
	while(true)
	{
		//IO.P5.write(i++ & 1);
		IO.P5.write(kRegularFont[i++ & 0xFF]);
	}
}
